// SPDX-License-Identifier: MIT
/**
 * Sistema de criação de arquivos de tipos
 * Cria tipos no diretório configurado (conventions.typesDirectory) com organização correta
 */

import { promises as fs } from 'node:fs';
import path from 'node:path';

import { buildTypesFsPath } from '@core/config/conventions.js';

import type { ExistingType, TypeAnalysis } from '@';

import { toKebabCase } from './context-analyzer.js';

/**
 * Cria definição de tipo no diretório configurado (conventions.typesDirectory)
 */
export async function createTypeDefinition(
  analysis: TypeAnalysis,
  sourceFilePath: string,
): Promise<string> {
  const domain = extractDomain(sourceFilePath);
  const fileName = toKebabCase(analysis.typeName);
  const typePath = buildTypesFsPath(path.posix.join(domain, `${fileName}.ts`));

  // Verificar se tipo já existe
  const existing = await findExistingType(analysis.typeName);
  if (existing) {
    // Retornar caminho do alias existente
    return `@types/types`; // Usar export centralizado
  }

  // Criar diretório se não existir
  const dir = path.dirname(typePath);
  await fs.mkdir(dir, { recursive: true });

  // Gerar conteúdo do arquivo
  const content = generateTypeFileContent(analysis, sourceFilePath);

  // Escrever arquivo
  await fs.writeFile(typePath, content, 'utf-8');

  // Adicionar export ao index.ts do domínio
  await addExportToIndex(domain, fileName);

  // Retornar alias de import
  return `@types/types`;
}

/**
 * Busca tipo existente no diretório configurado (conventions.typesDirectory)
 */
export async function findExistingType(
  typeName: string,
): Promise<ExistingType | null> {
  try {
    const tiposDir = buildTypesFsPath('');
    const types = await scanTypesDirectory(tiposDir);

    for (const type of types) {
      if (type.name === typeName) {
        return type;
      }
    }

    return null;
  } catch {
    return null;
  }
}

/**
 * Verifica se dois tipos são iguais
 */
export function isSameType(type1: ExistingType, type2: string): boolean {
  // Simplificado - em produção, usar parser para comparação estrutural
  const normalize = (str: string) => str.replace(/\s+/g, ' ').trim();
  return normalize(type1.definition) === normalize(type2);
}

/**
 * Gera conteúdo do arquivo de tipo
 */
function generateTypeFileContent(
  analysis: TypeAnalysis,
  sourceFilePath: string,
): string {
  const date = new Date().toISOString();

  return `// SPDX-License-Identifier: MIT
/**
 * Tipo gerado automaticamente
 * Origem: ${sourceFilePath}
 * Confiança: ${analysis.confidence}%
 * Data: ${date}
 *
 * @generated by doutor fix-any-to-proper-type
 */

${analysis.typeDefinition}
`;
}

/**
 * Adiciona export ao index.ts do domínio
 */
async function addExportToIndex(
  domain: string,
  fileName: string,
): Promise<void> {
  const indexPath = buildTypesFsPath(path.posix.join(domain, 'index.ts'));

  try {
    // Verificar se arquivo index.ts existe
    await fs.access(indexPath);

    // Ler conteúdo atual
    const content = await fs.readFile(indexPath, 'utf-8');

    // Verificar se export já existe
    const exportStatement = `export * from './${fileName}.js';`;
    if (content.includes(exportStatement)) {
      return; // Já existe
    }

    // Adicionar export
    await fs.appendFile(indexPath, `${exportStatement}\n`, 'utf-8');
  } catch {
    // Criar index.ts se não existir
    const header = `// SPDX-License-Identifier: MIT
/**
 * Exports do domínio ${domain}
 */

`;
    const exportStatement = `export * from './${fileName}.js';\n`;
    await fs.writeFile(indexPath, header + exportStatement, 'utf-8');
  }
}

/**
 * Extrai domínio do caminho do arquivo
 */
function extractDomain(filePath: string): string {
  const match = filePath.match(/src[\\/]([\w-]+)[\\/]/);
  return match ? match[1] : 'shared';
}

/**
 * Escaneia diretório de tipos
 */
async function scanTypesDirectory(dir: string): Promise<ExistingType[]> {
  const types: ExistingType[] = [];

  try {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        // Recursivo
        const subTypes = await scanTypesDirectory(fullPath);
        types.push(...subTypes);
      } else if (entry.name.endsWith('.ts') && entry.name !== 'index.ts') {
        // Ler arquivo e extrair tipos
        const content = await fs.readFile(fullPath, 'utf-8');
        const extractedTypes = extractTypesFromFile(content, fullPath);
        types.push(...extractedTypes);
      }
    }
  } catch {
    // Ignorar erros
  }

  return types;
}

/**
 * Extrai tipos de um arquivo
 */
function extractTypesFromFile(
  content: string,
  filePath: string,
): ExistingType[] {
  const types: ExistingType[] = [];

  // Regex simples para encontrar interfaces e types exportados
  const interfaceRegex = /export\s+interface\s+(\w+)\s*{([^}]*)}/g;
  const typeRegex = /export\s+type\s+(\w+)\s*=\s*([^;]+);/g;

  let match;

  // Interfaces
  while ((match = interfaceRegex.exec(content)) !== null) {
    types.push({
      name: match[1],
      path: filePath,
      definition: match[0],
      isExported: true,
      domain: extractDomain(filePath),
    });
  }

  // Types
  while ((match = typeRegex.exec(content)) !== null) {
    types.push({
      name: match[1],
      path: filePath,
      definition: match[0],
      isExported: true,
      domain: extractDomain(filePath),
    });
  }

  return types;
}
